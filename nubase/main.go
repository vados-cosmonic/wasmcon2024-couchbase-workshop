//go:generate go run github.com/bytecodealliance/wasm-tools-go/cmd/wit-bindgen-go generate --world nubase --out gen ../wit
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/ucarion/urlpath"

	jsonpatch "github.com/evanphx/json-patch"

	// This dependency enables ergonomic HTTP handlers in Golang,
	// it has `wasi:http` wrappers and goodies in it that enables us to write
	// convenient handler code (e.g. `wasihttp.HandleFunc`).
	"go.wasmcloud.dev/component/net/wasihttp"

	// This depdency contains commonly used basic types made available by the Componet Model
	//
	// To figure out how to use the types in here, see
	// - https://github.com/bytecodealliance/go-modules/blob/main/cm/result.go
	"github.com/bytecodealliance/wasm-tools-go/cm"

	// This package contains code generated by wit-bindgen (https://github.com/bytecodealliance/wit-bindgen)
	// which builds Go bindings for WIT interfaces.
	//
	// `import`s can be used via the code available here
	//
	// To figure out how to use the types in here, see
	// - gen/wasmcloud/couchbase/document/document.wit.go (generated, present locally)
	// - gen/wasmcloud/couchbase/types/types.wit.go (generated, present locally)
	document "github.com/vados-cosmonic/wasmcon2024-couchbase-workshop/nubase/gen/wasmcloud/couchbase/document"
	types "github.com/vados-cosmonic/wasmcon2024-couchbase-workshop/nubase/gen/wasmcloud/couchbase/types"
)

// Since we don't run this program like a CLI, the `main` function is empty.
// Instead, setup is done via the `init` function
func main() {}

var getStatusPath = urlpath.New("/api/v1/_status")
var documentsByIdPath = urlpath.New("/api/v1/documents/:id")
var upsertByIdPath = urlpath.New("/api/v1/documents/:id/upsert")
var batchInsertPath = urlpath.New("/api/v1/batch/insert")
var batchUpsertPath = urlpath.New("/api/v1/batch/upsert")

// Batch of documents to be used for some operation
type DocmentBatch struct {
	// Documents that should be inserted as part of the batch
	Docs map[string]interface{} `json:"docs"`
}

// Type that represents a JSON patch operation
type JSONPatchOp struct {
	Op    string      `json:"op"`              // Operation type (e.g., "add", "remove", "replace", "move", "copy", "test")
	Path  string      `json:"path"`            // Target path for the operation
	Value interface{} `json:"value,omitempty"` // The value to add, replace, or test (optional depending on the operation)
	From  string      `json:"from,omitempty"`  // Source path for "move" or "copy" operations (optional)
}

// Upsert specification for a single document
type Upsert struct {
	// Document ID
	DocID string `json:"docId"`
	// Documents that should be inserted as part of the batch
	Patches []JSONPatchOp `json:"patches",omitempty`
	// Object to insert if the document does not exist
	Insert map[string]interface{} `json:"insert"`
}

// Multiple upserts to be performed
type UpsertBatch struct {
	Upserts []Upsert `json:"upserts"`
}

// Multiple inserts to be performed
type InsertBatch struct {
	Docs []BatchInsert `json:"docs"`
}

// Upsert specification for a single document
type BatchInsert struct {
	// Document ID
	DocID string `json:"docId"`
	// Object to insert
	Doc map[string]interface{} `json:"doc"`
}

// Entrypoint for the WebAssembly component
func init() {

	wasihttp.HandleFunc(func(w http.ResponseWriter, r *http.Request) {

		// GET /api/v1/_status
		if _, ok := getStatusPath.Match(r.URL.Path); ok && r.Method == http.MethodGet {
			handleStatus(w, r)
			return
		}

		// GET /api/v1/documents/:id
		if match, ok := documentsByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodGet {
			handleGetSingleDocumentById(w, r, match.Params["id"])
			return
		}

		// POST /api/v1/documents/:id
		if match, ok := documentsByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleInsertDocument(w, r, match.Params["id"])
			return
		}

		// DELETE /api/v1/documents/:id
		if match, ok := documentsByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodDelete {
			handleDeleteSingleDocumentById(w, r, match.Params["id"])
			return
		}

		// POST /api/v1/documents/:id/upsert
		if match, ok := upsertByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleUpsertDocument(w, r, match.Params["id"])
			return
		}

		// POST /api/v1/batch/insert
		if _, ok := batchInsertPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleBatchInsert(w, r)
			return
		}

		// POST /api/v1/batch/upsert
		if _, ok := documentsByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleBatchUpsert(w, r)
			return
		}

		sendErrorResponse(w, fmt.Sprintf("unrecognized path [%s]", r.URL.Path))

	})
}

/////////////////////////////
// Handler Implementations //
/////////////////////////////

// Handle the status endpoint
func handleStatus(w http.ResponseWriter, r *http.Request) {
	sendSuccessResponse(w, "ok")
}

// Handle inserting a single document
func handleInsertDocument(w http.ResponseWriter, r *http.Request, documentId string) {
	// Read the HTTP request body
	doc, err := ioutil.ReadAll(r.Body)
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to get request body: %s", err))
		return
	}
	defer r.Body.Close()

	// Retrieve the document, using the generated bindings for `wasmcloud:couchbase/documents.get@0.1.0-draft`
	res := document.Insert(types.DocumentID(documentId), types.DocumentRaw(types.JSONString(doc)), cm.None[document.DocumentInsertOptions]())
	if res.IsErr() {
		sendErrorResponse(w, fmt.Sprintf("insert operation failed: %s", res.Err()))
		return
	}

	sendSuccessResponse(w, res.OK())
}

// Handle retrieving a single document by ID
func handleGetSingleDocumentById(w http.ResponseWriter, r *http.Request, documentId string) {
	// Retrieve the document, using the generated bindings for `wasmcloud:couchbase/documents.get@0.1.0-draft`
	res := document.Get(types.DocumentID(documentId), cm.None[document.DocumentGetOptions]())
	if res.IsErr() {
		sendErrorResponse(w, fmt.Sprintf("get operation failed: %s", res.Err()))
		return
	}
	doc := res.OK()

	var parsed interface{}
	err := json.Unmarshal([]byte(*doc.Document.Raw()), &parsed)
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to unmarshal document: %s", err))
		return
	}

	sendSuccessResponse(w, parsed)
}

// Handle deleting a single document by ID
func handleDeleteSingleDocumentById(w http.ResponseWriter, r *http.Request, documentId string) {
	// Delete the document, using the generated bindings for `wasmcloud:couchbase/documents.delete@0.1.0-draft`
	res := document.Remove(types.DocumentID(documentId), cm.None[document.DocumentRemoveOptions]())
	if err := res.Err(); err != nil {
		sendErrorResponse(w, fmt.Sprintf("delete operation failed: %s", err))
		return
	}

	sendSuccessResponse(w, documentId)
}

// Handle inserting a batch of documents
func handleBatchInsert(w http.ResponseWriter, r *http.Request) {
	// Read the HTTP request body
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to get request body: %s", err))
		return
	}
	defer r.Body.Close()

	// Parse the insert batch
	var batch InsertBatch
	jsonErr := json.Unmarshal(body, &batch)
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to unmarshal request body JSON: %s", jsonErr))
		return
	}

	// NOTE: This is *not* an efficient insert, but is easy for understanding!
	documentIds := []string{}
	for _, d := range batch.Docs {
		// Marshal the insertDocument data to patch it
		insertDocData, insertDocMarshalErr := json.Marshal(d.Doc)
		if insertDocMarshalErr != nil {
			sendSuccessResponse(w, documentIds)
			return
		}
		if insertDocData == nil {
			sendSuccessResponse(w, documentIds)
			return
		}

		// Insert the document
		insertRes := document.Insert(types.DocumentID(d.DocID), types.DocumentRaw(types.JSONString(insertDocData)), cm.None[document.DocumentInsertOptions]())
		if insertErr := insertRes.Err(); insertErr != nil {
			sendSuccessResponse(w, documentIds)
			return
		}

		documentIds = append(documentIds, d.DocID)
	}

	sendSuccessResponse(w, documentIds)
}

// Handle upserting a document
func handleUpsertDocument(w http.ResponseWriter, r *http.Request, documentId string) {
	// Read the HTTP request body
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to get request body: %s", err))
		return
	}
	defer r.Body.Close()

	// Parse the upsert from the request body
	var patch Upsert
	jsonErr := json.Unmarshal(body, &patch)
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to unmarshal request body JSON: %s", jsonErr))
		return
	}

	// Ensure the IDs match
	if &patch.DocID != nil && patch.DocID != documentId {
		sendErrorResponse(w, fmt.Sprintf("document ID specified in body [%s] does not match path [%s]", patch.DocID, documentId))
		return
	}

	// Read the document
	getRes := document.Get(types.DocumentID(documentId), cm.None[document.DocumentGetOptions]())
	if getRes.IsErr() {
		getResErr := getRes.Err()
		if *getResErr == types.DocumentErrorNotFound { // If the doc wasn't found, insert it and return early

			// Marshal the insertDocument data to patch it
			insertDocData, insertDocMarshalErr := json.Marshal(patch.Insert)
			if insertDocMarshalErr != nil {
				sendErrorResponse(w, fmt.Sprintf("failed to marshal insert document: %s", insertDocMarshalErr))
				return
			}
			if insertDocData == nil {
				sendErrorResponse(w, "invalid insert doc data (cannot be nil)")
				return
			}

			// Insert the document
			insertRes := document.Insert(types.DocumentID(documentId), types.DocumentRaw(types.JSONString(insertDocData)), cm.Some(document.DocumentInsertOptions{
				TimeoutNs: cm.Some(uint64(time.Second.Nanoseconds())),
			}))
			if insertErr := insertRes.Err(); insertErr != nil {
				sendErrorResponse(w, fmt.Sprintf("insert operation failed: %s", insertErr))
				return
			}
			sendSuccessResponse(w, documentId)
		} else { // If some other error occurred, return it
			sendErrorResponse(w, fmt.Sprintf("get operation failed: %s", getResErr))
		}
		return
	}
	doc := getRes.OK()

	// Marshal the patch json data
	patchesData, patchesMarshalErr := json.Marshal(patch.Patches)
	if patchesMarshalErr != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to marshal patched document: %s", patchesMarshalErr))
		return
	}
	if patchesData == nil {
		sendErrorResponse(w, "invalid patches data (cannot be nil)")
		return
	}

	// Decode all the patches
	patches, err := jsonpatch.DecodePatch(patchesData)
	if err != nil {
		sendErrorResponse(w, "failed to decode patches")
		return
	}

	// Patch the document
	patched, err := patches.Apply([]byte(*doc.Document.Raw()))
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to apply patches: %s", err))
		return
	}

	// Replace the existing document
	replaceRes := document.Replace(types.DocumentID(documentId), types.DocumentRaw(types.JSONString(patched)), cm.Some(document.DocumentReplaceOptions{
		Cas:       doc.Cas,
		TimeoutNs: cm.Some(uint64(time.Second.Nanoseconds())),
	}))
	if replaceRes.IsErr() {
		sendErrorResponse(w, fmt.Sprintf("patch operation failed: %s", replaceRes.Err()))
		return
	}

	sendSuccessResponse(w, documentId)
}

// Handle updating batches of documents
func handleBatchUpsert(w http.ResponseWriter, r *http.Request) {
	// TODO: IMPLEMENT THIS!
	sendSuccessResponse(w, "handleBatchUpsert")
}

///////////////
// Utilities //
///////////////

// Response is a generic struct that holds any data of type T
type SuccessResponse[T any] struct {
	Status string `json:"status"`
	Data   T      `json:"data,omitempty"`
}

func makeSuccessResponse[T any](data T) SuccessResponse[T] {
	return SuccessResponse[T]{
		Status: "success",
		Data:   data,
	}
}

func sendSuccessResponse[T any](w http.ResponseWriter, data T) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(makeSuccessResponse(data)); err != nil {
		http.Error(w, fmt.Sprintf("unexpected failure while building response: %s", err), http.StatusInternalServerError)
	}
}

// Response is a generic struct that holds any data of type T
type ErrorResponse struct {
	Status string `json:"status"`
	Error  string `json:"error,omitempty"`
}

func makeErrorResponse(msg string) ErrorResponse {
	return ErrorResponse{
		Status: "error",
		Error:  msg,
	}
}

func sendErrorResponse(w http.ResponseWriter, msg string) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(makeErrorResponse(msg)); err != nil {
		http.Error(w, fmt.Sprintf("unexpected failure while building response: %s", err), http.StatusInternalServerError)
	}
}
