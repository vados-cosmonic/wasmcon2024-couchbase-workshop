//go:generate go run github.com/bytecodealliance/wasm-tools-go/cmd/wit-bindgen-go generate --world nubase --out gen ../wit
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/ucarion/urlpath"

	// This dependency enables ergonomic HTTP handlers in Golang,
	// it has `wasi:http` wrappers and goodies in it that enables us to write
	// convenient handler code (e.g. `wasihttp.HandleFunc`).
	"go.wasmcloud.dev/component/net/wasihttp"

	// To figure out how to use the types in here, see
	// - https://github.com/bytecodealliance/go-modules/blob/main/cm/result.go
	"github.com/bytecodealliance/wasm-tools-go/cm"

	// This package contains code generated by wit-bindgen (https://github.com/bytecodealliance/wit-bindgen)
	// which builds Go bindings for WIT interfaces.
	//
	// `import`s can be used via the code available here
	//
	// To figure out how to use the types in here, see
	// - gen/wasi/keyvalue/store/store.wit.go (generated, present locally)
	// - gen/wasi/keyvalue/atomics/atomics.wit.go (generated, present locally)
	store "github.com/vados-cosmonic/wasmcon2024-couchbase-workshop/gen/wrpc/keyvalue/store"
	// atomics "github.com/vados-cosmonic/wasmcon2024-couchbase-workshop/gen/wasi/keyvalue/atomics"
)

// Since we don't run this program like a CLI, the `main` function is empty.
// Instead, setup is done via the `init` function
func main() {}

const (
	bucket = "nudb"
)

var getStatusPath = urlpath.New("/api/v1/_status")
var keyByIdPath = urlpath.New("/api/v1/keys/:key")
var lockPath = urlpath.New("/api/v1/keys/:key/lock")
var unlockPath = urlpath.New("/api/v1/keys/:key/unlock")

// TODO: Implement the following APIs
// var upsertByKeyPath = urlpath.New("/api/v1/keys/:key/upsert")
// var batchInsertPath = urlpath.New("/api/v1/batch/insert")
// var batchUpsertPath = urlpath.New("/api/v1/batch/upsert")

// Entrypoint for the WebAssembly component
func init() {

	wasihttp.HandleFunc(func(w http.ResponseWriter, r *http.Request) {

		// GET /api/v1/_status
		if _, ok := getStatusPath.Match(r.URL.Path); ok && r.Method == http.MethodGet {
			handleStatus(w, r)
			return
		}

		// GET /api/v1/keys/:key
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodGet {
			handleGetKey(w, r, match.Params["key"])
			return
		}

		// POST /api/v1/keys/:key
		// PUT /api/v1/keys/:key
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost || r.Method == http.MethodPut {
			handleInsertDocumentForKey(w, r, match.Params["key"])
			return
		}

		// POST /api/v1/keys/:key/lock
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleLockKey(w, r, match.Params["key"])
			return
		}

		// POST /api/v1/keys/:key/unlock
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleUnlockKey(w, r, match.Params["key"])
			return
		}

		// TODO: Add a match & handler call for the Upsert API (upsertByKeyPath)
		// TODO: Add a match & handler call for the batchInsert API (batchInsertPath)
		// TODO: Add a match & handler call for the batchUpsert API (batchUpsertPathT)

		sendErrorResponse(w, fmt.Sprintf("unrecognized path [%s]", r.URL.Path))
	})
}

// Handle the status endpoint
func handleStatus(w http.ResponseWriter, r *http.Request) {
	sendSuccessResponse(w, "ok")
}

// Handle retrieving the document for a given key
func handleGetKey(w http.ResponseWriter, r *http.Request, key string) {
	// Retrieve the value
	value_res := store.Get(bucket, key)
	if value_res.Err() != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to retrieve value: %s", value_res.Err()))
		return
	}
	value := value_res.OK()

	sendSuccessResponse(w, value)
}

// Handle inserting a document at a given key
func handleInsertDocumentForKey(w http.ResponseWriter, r *http.Request, key string) {
	bytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to get request body: %s", err))
		return
	}
	defer r.Body.Close()

	// Ensure the body is valid JSON document
	var payload map[string]interface{}
	if err := json.Unmarshal(bytes, &payload); err != nil {
		sendErrorResponse(w, fmt.Sprintf("invalid JSON body: %s", err))
		return
	}

	value_res := store.Set("nudb", key, cm.ToList(bytes))
	if value_res.Err() != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to retrieve value: %s", value_res.Err()))
		return
	}
	value := value_res.OK()

	sendSuccessResponse(w, value)
}

// Handle locking a document at a given key
func handleLockKey(w http.ResponseWriter, r *http.Request, key string) {
	sendSuccessResponse(w, "handleLockKey")
}

// Handle unlocking a document at a given key
func handleUnlockKey(w http.ResponseWriter, r *http.Request, key string) {
	sendSuccessResponse(w, "handleUnlockKey")
}

// // TODO: Handle upserting a single document with a given key
// func handleUpsertByKey(w http.ResponseWriter, r *http.Request, key string) {
//	sendSuccessResponse(w, "handleBatchKey")
// }

// // TODO: Handle batch inserting one or more documents
// func handleBatchInsert(w http.ResponseWriter, r *http.Request, key string) {
//	sendSuccessResponse(w, "handleBatchKey")
// }

// // TODO: Handle batch upserting one or more documents
// func handleBatchUpsert(w http.ResponseWriter, r *http.Request, key string) {
//	sendSuccessResponse(w, "handleBatchKey")
// }

// Response is a generic struct that holds any data of type T
type SuccessResponse[T any] struct {
	Status string `json:"status"`
	Data   T      `json:"data,omitempty"`
}

func makeSuccessResponse[T any](data T) SuccessResponse[T] {
	return SuccessResponse[T]{
		Status: "success",
		Data:   data,
	}
}

func sendSuccessResponse[T any](w http.ResponseWriter, data T) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(makeSuccessResponse(data)); err != nil {
		http.Error(w, fmt.Sprintf("unexpected failure while building response: %s", err), http.StatusInternalServerError)
	}
}

// Response is a generic struct that holds any data of type T
type ErrorResponse struct {
	Status string `json:"status"`
	Error  string `json:"error,omitempty"`
}

func makeErrorResponse(msg string) ErrorResponse {
	return ErrorResponse{
		Status: "error",
		Error:  msg,
	}
}

func sendErrorResponse(w http.ResponseWriter, msg string) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(makeErrorResponse(msg)); err != nil {
		http.Error(w, fmt.Sprintf("unexpected failure while building response: %s", err), http.StatusInternalServerError)
	}
}
