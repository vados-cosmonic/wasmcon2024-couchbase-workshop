//go:generate go run github.com/bytecodealliance/wasm-tools-go/cmd/wit-bindgen-go generate --world nubase --out gen ../wit
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/ucarion/urlpath"

	// This dependency enables ergonomic HTTP handlers in Golang,
	// it has `wasi:http` wrappers and goodies in it that enables us to write
	// convenient handler code (e.g. `wasihttp.HandleFunc`).
	"go.wasmcloud.dev/component/net/wasihttp"

	// To figure out how to use the types in here, see
	// - https://github.com/bytecodealliance/go-modules/blob/main/cm/result.go
	"github.com/bytecodealliance/wasm-tools-go/cm"

	// This package contains code generated by wit-bindgen (https://github.com/bytecodealliance/wit-bindgen)
	// which builds Go bindings for WIT interfaces.
	//
	// `import`s can be used via the code available here
	//
	// To figure out how to use the types in here, see
	// - gen/wasi/keyvalue/store/store.wit.go (generated, present locally)
	// - gen/wasi/keyvalue/atomics/atomics.wit.go (generated, present locally)
	kv_store "github.com/vados-cosmonic/wasmcon2024-couchbase-workshop/gen/wasi/keyvalue/store"
	// kv_atomics "github.com/vados-cosmonic/wasmcon2024-couchbase-workshop/gen/wasi/keyvalue/atomics"
)

// Since we don't run this program like a CLI, the `main` function is empty.
// Instead, setup is done via the `init` function
func main() {}

var getStatusPath = urlpath.New("/api/v1/_status")
var keyByIdPath = urlpath.New("/api/v1/keys/:key")
var lockPath = urlpath.New("/api/v1/keys/:key/lock")
var unlockPath = urlpath.New("/api/v1/keys/:key/unlock")

// Entrypoint for the WebAssembly component
func init() {

	wasihttp.HandleFunc(func(w http.ResponseWriter, r *http.Request) {

		// GET /api/v1/_status
		if _, ok := getStatusPath.Match(r.URL.Path); ok && r.Method == http.MethodGet {
			handleStatus(w, r)
			return
		}

		// GET /api/v1/keys/:key
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodGet {
			handleGetKey(w, r, match.Params["key"])
			return
		}

		// POST /api/v1/keys/:key
		// PUT /api/v1/keys/:key
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost || r.Method == http.MethodPut {
			handleInsertDocumentForKey(w, r, match.Params["key"])
			return
		}

		// POST /api/v1/keys/:key/lock
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleLockKey(w, r, match.Params["key"])
			return
		}

		// POST /api/v1/keys/:key/unlock
		if match, ok := keyByIdPath.Match(r.URL.Path); ok && r.Method == http.MethodPost {
			handleUnlockKey(w, r, match.Params["key"])
			return
		}

		sendErrorResponse(w, fmt.Sprintf("unrecognized path [%s]", r.URL.Path))
	})
}

// Handle the status endpoint
func handleStatus(w http.ResponseWriter, r *http.Request) {
	sendSuccessResponse(w, "ok")
}

// Handle retrieving the document for a given key
func handleGetKey(w http.ResponseWriter, r *http.Request, key string) {
	// Open the nudb bucket
	bucket_res := kv_store.Open("nudb"); if bucket_res.Err() != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to open bucket: %s", bucket_res.Err()))
		return
	}
	bucket := bucket_res.OK()

	// Retrieve the value
	value_res := bucket.Get(key); if value_res.Err() != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to retrieve value: %s", value_res.Err()))
		return
	}
	value := value_res.OK();

	// if err := res.Err(); err != nil {
	//	sendErrorResponse(w, fmt.Sprintf("get operation failed: %s", err))
	//	return
	// }

	sendSuccessResponse(w, value)
}

// Handle inserting a document at a given key
func handleInsertDocumentForKey(w http.ResponseWriter, r *http.Request, key string) {
	doc, err := ioutil.ReadAll(r.Body); if err != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to get request body: %s", err))
		return
	}
	defer r.Body.Close()

	// TODO: Ensure the body is valid JSON

	// Convert the body to bytes
	bytes := cm.ToList(doc)

	// Open the nudb bucket
	bucket_res := kv_store.Open("nudb"); if bucket_res.Err() != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to open bucket: %s", bucket_res.Err()))
		return
	}
	bucket := bucket_res.OK()

	value_res := bucket.Set(key, bytes); if value_res.Err() != nil {
		sendErrorResponse(w, fmt.Sprintf("failed to retrieve value: %s", value_res.Err()))
		return
	}
	value := value_res.OK();

	sendSuccessResponse(w, value)
}

// Handle locking a document at a given key
func handleLockKey(w http.ResponseWriter, r *http.Request, key string) {
	sendSuccessResponse(w, "handleLockKey")
}

// Handle unlocking a document at a given key
func handleUnlockKey(w http.ResponseWriter, r *http.Request, key string) {
	sendSuccessResponse(w, "handleUnlockKey")
}

// // Handle inserting a single document
// func handleInsertDocument(w http.ResponseWriter, r *http.Request, documentId string) {
//	// Read the HTTP request body
//	doc, err := ioutil.ReadAll(r.Body)
//	if err != nil {
//		sendErrorResponse(w, fmt.Sprintf("failed to get request body: %s", err))
//		return
//	}
//	defer r.Body.Close()

//	// Retrieve the document, using the generated bindings for `wasmcloud:couchbase/documents.get@0.1.0-draft`
//	res := document.Insert(types.DocumentID(documentId), types.DocumentRaw(types.JSONString(doc)), cm.None[document.DocumentInsertOptions]())
//	if err := res.Err(); err != nil {
//		sendErrorResponse(w, fmt.Sprintf("operation failed: %s", err))
//		return
//	}

//	sendSuccessResponse(w, res.OK())
// }

// // Handle retrieving a single document by ID
// func handleGetSingleDocumentById(w http.ResponseWriter, r *http.Request, documentId string) {
//	// Retrieve the document, using the generated bindings for `wasmcloud:couchbase/documents.get@0.1.0-draft`
//	res := document.Get(types.DocumentID(documentId), cm.None[document.DocumentGetOptions]())
//	// TODO: check for error

//	sendSuccessResponse(w, res)
// }

// // Handle deleting a single document by ID
// func handleDeleteSingleDocumentById(w http.ResponseWriter, r *http.Request, documentId string) {
//	sendSuccessResponse(w, "handleDeleteSingleDocumentById")
// }

// // Handle getting the latest inserted document
// func handleGetLatestDocument(w http.ResponseWriter, r *http.Request) {
//	sendSuccessResponse(w, "handleGetLatestDocument")
// }

// Response is a generic struct that holds any data of type T
type SuccessResponse[T any] struct {
	Status string `json:"status"`
	Data   T      `json:"data,omitempty"`
}

func makeSuccessResponse[T any](data T) SuccessResponse[T] {
	return SuccessResponse[T]{
		Status: "success",
		Data:   data,
	}
}

func sendSuccessResponse[T any](w http.ResponseWriter, data T) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(makeSuccessResponse(data)); err != nil {
		http.Error(w, fmt.Sprintf("unexpected failure while building response: %s", err), http.StatusInternalServerError)
	}
}

// Response is a generic struct that holds any data of type T
type ErrorResponse struct {
	Status string `json:"status"`
	Error  string `json:"error,omitempty"`
}

func makeErrorResponse(msg string) ErrorResponse {
	return ErrorResponse{
		Status: "error",
		Error:  msg,
	}
}

func sendErrorResponse(w http.ResponseWriter, msg string) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(makeErrorResponse(msg)); err != nil {
		http.Error(w, fmt.Sprintf("unexpected failure while building response: %s", err), http.StatusInternalServerError)
	}
}
